package pentago;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Contains methods for iterating through, manipulating, and getting the next choice of a game tree. 
 * @author Cade Reynoldson
 */
public class GameTree {
    
    /** The head node of the tree. */
    private GameTreeNode headNode; 
    
    /** The previous choice of the game tree. Either generated by the user or the AI. */
    private GameTreeNode currentNode; 
    
    /** Indicates if this tree uses alpha beta pruning. */
    private boolean alphaBetaPruning;
    
    /** The turn lookahead count. Indicates how many nodes to expand. */
    private int turnLookAhead;
    
    /** The current *MAX* depth of the gametree. */
    private int currentDepth;
    
    /** The evaluation function to use on this tree. */
    private UtilityFunction evaluationFunction;
    
    /**
     * Representation of a game tree. Only create when it is the AI's turn!
     * @param originalState the original state of the game tree. 
     * @param aiToken the token to be used with the AI. 
     */ 
    public GameTree(char[][] originalState, char aiToken, int lookAheadDepth, UtilityFunction f, boolean alphaBetaPruning) {
        headNode = new GameTreeNode(null, originalState, aiToken, 0, aiToken == 'b', "none");
        currentDepth = 0;
        evaluationFunction = f;
        turnLookAhead = lookAheadDepth;
        this.alphaBetaPruning = alphaBetaPruning;
        currentNode = headNode;
        checkExpansion();
    }
    
    /**
     * Returns the next choice of the tree. 
     * @return the next choice of the tree. 
     */
    public GameTreeNode getNext() {
        HashMap<String, GameTreeNode> children = currentNode.getChildren();
        String currentArgs = ""; //The agrument that this node will choose to have. 
        int value;
        checkExpansion();
        if (currentNode.isMaximizer()) //If the currentNode is a maximizer. 
            value = Integer.MIN_VALUE;
        else 
            value = Integer.MAX_VALUE;
        for (String key : children.keySet()) {
            int childScore = children.get(key).getScore();
            if (currentNode.isMaximizer()) { //Maximizer logic
                if (childScore > value) {
                    currentArgs = key;
                    value = childScore;
                    if (value == Integer.MAX_VALUE) //If the value is a max value, it's a win. 
                        break;
                }
            } else { // Minimizer logic
                if (childScore < value) {
                    currentArgs = key;
                    value = childScore; 
                    if (value == Integer.MIN_VALUE) //If the value is a min value, it's a win.
                        break;
                }
            }
        }
        GameTreeNode nextNode = children.get(currentArgs);
        currentNode = nextNode;
        return nextNode;
    }
    
    /**
     * Updates the next choice based on user input from the main pentago program. 
     * @param args the arguments that are used to form the next node. 
     * @return the next state. 
     */
    public char[][] updateNext(String args) {
        currentNode = currentNode.getChildren().get(args.toLowerCase());
        checkExpansion();
        return currentNode.getState();
    }
    
    /**
     * Checks to see if the current node is a leaf. 
     * If the current node is a leaf, expand and evaluate using either minimax or alpha beta. 
     */
    public void checkExpansion() {
        if (currentNode.isLeaf()) { //If this node is a leaf, we've reached the bottom of the tree.
            currentNode.expand(currentDepth + turnLookAhead); //Expand node to next turn look ahead. 
            currentDepth += turnLookAhead; //Update the current depth of the tree. 
            currentNode.evaluate(evaluationFunction);
            if (alphaBetaPruning)
                alphaBeta(currentNode, Integer.MIN_VALUE, Integer.MAX_VALUE);
            else
                miniMax(currentNode);
        }
    }
    
    /**
     * Evaluates the tree using the minimax algorithm starting with a specified node.  
     */
    public void miniMax(GameTreeNode node) {
        if (node.isLeaf()) //If this node is a leaf, there is nothing to do - return!
            return;
        HashMap<String, GameTreeNode> children = node.getChildren();
        if (!node.isEvaluated()) { //If this node has not been evaluated, run minimax on it's children first!
            for (String key : children.keySet()) { // for all children, assure that they have had their scores established!
                miniMax(children.get(key));
            }
        }
        int value;
        if (node.isMaximizer()) //If the node is a maximizer, initialize value with the lowest possible number! 
            value = Integer.MIN_VALUE;
        else //If the node is a minimizer, initialize value with the maximum possible integer!
            value = Integer.MAX_VALUE; 
        for (String key : children.keySet()) { //After all children have been rated, loop through the evaluations to establish a score. 
            int childScore = children.get(key).getScore();
            if (node.isMaximizer()) { //Maximizer node
                if (childScore > value) //if this child's score is greater than the current value, change value. 
                    value = childScore;
                if (value == Integer.MAX_VALUE) //if this node is a maximizer node, a win has been detected! break!
                    break;
            } else { //Minimizer node
                if (childScore < value)
                    value = childScore;
                if (value == Integer.MIN_VALUE) //if this node is a minimizer node, a win has been detected! break! 
                    break;
            }
        }
        node.setScore(value);
    }
    
    /**
     * Evaluates the tree with alpha-beta pruning on a specific gametree node. 
     * - ASSUMES ALL LEAFS HAVE BEEN EVALUATED!
     * @param node the node to evaluate alpha beta on. 
     * @param the current alpha beta values of the node. 
     * @return an integer corresponding to the last alpha or beta value. 
     */
    public int alphaBeta(GameTreeNode node, int alpha, int beta) {
        if (node.isLeaf()) //if this node is a leaf, return. 
            return node.getScore();
        HashMap<String, GameTreeNode> children = node.getChildren();
        int value;
        boolean pruning = false;
        ArrayList<String> toPrune = new ArrayList<String>(); //An array list of arguments that are mapped to children to prune off. 
        if (node.isMaximizer()) { //if this node is a maximizer node, manipulate alpha value. 
            value = Integer.MIN_VALUE;
            for (String key : children.keySet()) {
                if (pruning) { //If we are pruning off children. 
                    toPrune.add(key);
                } else { //Else, we are still evaluating children. 
                    int evaluation = alphaBeta(children.get(key), alpha, beta);
                    if (evaluation > value)
                        value = evaluation;
                    alpha = Math.max(alpha, value); //Set alpha to be the max of the evaluation.
                    if (alpha >= beta) //if alpha is greater than or equal to beta, no longer evaluate children. We only prune them. 
                        pruning = true;
                }    
            }
        } else { //If this node is a minimizer, manipulate beta value. 
            value = Integer.MAX_VALUE;
            for (String key : children.keySet()) {
                if (pruning) { //If we are pruning off children.
                    toPrune.add(key);
                } else { //Else, we are still evaluating children. 
                    int evaluation = alphaBeta(children.get(key), alpha, beta); 
                    if (evaluation < value)
                        value = evaluation;
                    beta = Math.min(beta, value);
                    if (beta <= alpha)
                        pruning = true;
                }
            }
        }
        node.removeChildren(toPrune);
        node.setScore(value); //Set the score of this node equal to the calculated alpha beta value. 
        return value;
    }
}
